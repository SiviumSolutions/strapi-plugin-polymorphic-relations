var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// dist/_chunks/index-C8m5tCNb.js
var require_index_C8m5tCNb = __commonJS({
  "dist/_chunks/index-C8m5tCNb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var jsxRuntime = require("react/jsx-runtime");
    var react = require("react");
    var reactIntl = require("react-intl");
    var designSystem = require("@strapi/design-system");
    var admin = require("@strapi/strapi/admin");
    var index = require_index_BD8xr598();
    var Input = react.forwardRef((props, forwardedRef) => {
      const {
        disabled = false,
        name,
        required = false,
        error,
        hint,
        label,
        labelAction,
        value,
        onChange,
        attribute
      } = props;
      const { formatMessage } = reactIntl.useIntl();
      const { get } = admin.useFetchClient();
      const [contentTypes, setContentTypes] = react.useState([]);
      const [entities, setEntities] = react.useState([]);
      const [loadingTypes, setLoadingTypes] = react.useState(false);
      const [loadingEntities, setLoadingEntities] = react.useState(false);
      const parseValue = (val) => {
        if (!val)
          return null;
        try {
          const parsed = typeof val === "string" ? JSON.parse(val) : val;
          return parsed;
        } catch (e) {
          return null;
        }
      };
      const parsedValue = parseValue(value);
      const relationType = attribute?.options?.relationType || "one";
      const isMany = relationType === "many";
      const [activeContentType, setActiveContentType] = react.useState(
        !isMany && parsedValue && !Array.isArray(parsedValue) ? parsedValue.contentType : null
      );
      const [activeEntityId, setActiveEntityId] = react.useState(
        !isMany && parsedValue && !Array.isArray(parsedValue) ? parsedValue.id : null
      );
      react.useEffect(() => {
        const fetchContentTypes = async () => {
          setLoadingTypes(true);
          try {
            const { data } = await get("/polymorphic-relation/content-types");
            let types = data.data;
            let allowedTypes = [];
            const rawAllowedTypes = attribute?.options?.allowedTypes;
            if (typeof rawAllowedTypes === "string") {
              allowedTypes = rawAllowedTypes.split(",").map((t) => t.trim()).filter(Boolean);
            } else if (Array.isArray(rawAllowedTypes)) {
              allowedTypes = rawAllowedTypes;
            }
            if (allowedTypes.length > 0) {
              types = types.filter((t) => allowedTypes.includes(t.uid));
            }
            setContentTypes(types);
          } catch (error2) {
            console.error("Error fetching content types:", error2);
          } finally {
            setLoadingTypes(false);
          }
        };
        fetchContentTypes();
      }, [get, attribute?.options?.allowedTypes]);
      react.useEffect(() => {
        if (!activeContentType) {
          setEntities([]);
          return;
        }
        const fetchEntities = async () => {
          setLoadingEntities(true);
          try {
            const { data } = await get(
              `/polymorphic-relation/content-types/${activeContentType}/entities`,
              {
                params: {
                  pageSize: 100
                }
              }
            );
            setEntities(data.data || []);
          } catch (error2) {
            console.error("Error fetching entities:", error2);
          } finally {
            setLoadingEntities(false);
          }
        };
        fetchEntities();
      }, [activeContentType, get]);
      const emitChange = (newValue) => {
        if (!newValue) {
          onChange({ target: { name, value: null } });
          return;
        }
        onChange({
          target: {
            name,
            value: JSON.stringify(newValue)
          }
        });
      };
      const getEntityLabel = (entity) => {
        const displayField = attribute?.options?.displayField || "id";
        const label2 = entity[displayField] || entity.title || entity.name || entity.label || entity.documentId || entity.id;
        return String(label2);
      };
      const handleEntitySelect = (entityId) => {
        if (!activeContentType || !entityId)
          return;
        const selectedEntity = entities.find((e) => String(e.documentId || e.id) === entityId);
        const label2 = selectedEntity ? getEntityLabel(selectedEntity) : void 0;
        const newItem = {
          contentType: activeContentType,
          id: entityId,
          label: label2
        };
        if (isMany) {
          const currentList = Array.isArray(parsedValue) ? parsedValue : [];
          const exists = currentList.find(
            (item) => item.contentType === newItem.contentType && item.id === newItem.id
          );
          if (!exists) {
            emitChange([...currentList, newItem]);
          }
          setActiveEntityId(null);
        } else {
          setActiveEntityId(entityId);
          emitChange(newItem);
        }
      };
      const handleRemoveItem = (index2) => {
        if (!isMany || !Array.isArray(parsedValue))
          return;
        const newList = [...parsedValue];
        newList.splice(index2, 1);
        emitChange(newList);
      };
      const handleContentTypeChange = (newType) => {
        setActiveContentType(newType);
        setActiveEntityId(null);
        if (!isMany) {
          if (!newType)
            emitChange(null);
        }
      };
      const availableEntities = entities.filter((entity) => {
        if (!isMany)
          return true;
        const currentList = Array.isArray(parsedValue) ? parsedValue : [];
        return !currentList.some(
          (item) => item.contentType === activeContentType && item.id === String(entity.documentId || entity.id)
        );
      });
      const hasEntities = entities.length > 0;
      const allSelected = hasEntities && availableEntities.length === 0;
      return /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Root, { name, id: name, error, hint, required, children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { direction: "column", alignItems: "stretch", gap: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Label, { action: labelAction, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", children: label }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 2, direction: "column", alignItems: "stretch", children: [
          isMany && /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", textColor: "neutral600", children: "Add new relation:" }),
          /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 2, alignItems: "stretch", children: [
            /* @__PURE__ */ jsxRuntime.jsx("div", { style: { flex: 1 }, children: /* @__PURE__ */ jsxRuntime.jsx(
              designSystem.Combobox,
              {
                "aria-label": formatMessage({
                  id: index.getTranslation("field.contentType.placeholder"),
                  defaultMessage: "Select a content type"
                }),
                disabled: disabled || loadingTypes,
                value: activeContentType || void 0,
                placeholder: formatMessage({
                  id: index.getTranslation("field.contentType.placeholder"),
                  defaultMessage: "Select Type"
                }),
                onChange: handleContentTypeChange,
                autocomplete: { type: "list", filter: "contains" },
                children: contentTypes.map((type) => /* @__PURE__ */ jsxRuntime.jsx(designSystem.ComboboxOption, { value: type.uid, textValue: type.displayName, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { children: type.displayName }) }, type.uid))
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsx("div", { style: { flex: 1 }, children: /* @__PURE__ */ jsxRuntime.jsx(
              designSystem.Combobox,
              {
                "aria-label": formatMessage({
                  id: index.getTranslation("field.entity.placeholder"),
                  defaultMessage: "Select an entity"
                }),
                disabled: disabled || loadingEntities || allSelected || !hasEntities || !activeContentType,
                value: activeEntityId || "",
                placeholder: !activeContentType ? formatMessage({
                  id: index.getTranslation("field.entity.placeholder"),
                  defaultMessage: "Select Entity"
                }) : loadingEntities ? "Loading..." : !hasEntities ? "No entities found" : allSelected ? "All entities selected" : formatMessage({
                  id: index.getTranslation("field.entity.placeholder"),
                  defaultMessage: "Select Entity"
                }),
                onChange: handleEntitySelect,
                autocomplete: { type: "list", filter: "contains" },
                children: availableEntities.map((entity) => /* @__PURE__ */ jsxRuntime.jsx(
                  designSystem.ComboboxOption,
                  {
                    value: String(entity.documentId || entity.id),
                    textValue: getEntityLabel(entity),
                    children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { children: getEntityLabel(entity) })
                  },
                  entity.documentId || entity.id
                ))
              }
            ) })
          ] })
        ] }),
        isMany && Array.isArray(parsedValue) && parsedValue.length > 0 && /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { direction: "column", gap: 2, alignItems: "stretch", style: { marginTop: "8px" }, children: [
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", textColor: "neutral600", children: "Selected Relations:" }),
          parsedValue.map((item, idx) => {
            const typeInfo = contentTypes.find((t) => t.uid === item.contentType);
            const displayName = typeInfo?.displayName || item.contentType;
            const entityLabel = item.label || (entities.find(
              (e) => String(e.documentId || e.id) === item.id && activeContentType === item.contentType
            ) ? getEntityLabel(entities.find((e) => String(e.documentId || e.id) === item.id)) : `ID: ${item.id}`);
            return /* @__PURE__ */ jsxRuntime.jsxs(
              designSystem.Flex,
              {
                justifyContent: "space-between",
                alignItems: "center",
                background: "neutral0",
                borderColor: "neutral200",
                borderWidth: "1px",
                borderStyle: "solid",
                hasRadius: true,
                padding: 3,
                shadow: "tableShadow",
                children: [
                  /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 3, alignItems: "center", children: [
                    /* @__PURE__ */ jsxRuntime.jsx(
                      designSystem.Flex,
                      {
                        background: "primary100",
                        paddingLeft: 2,
                        paddingRight: 2,
                        paddingTop: 1,
                        paddingBottom: 1,
                        hasRadius: true,
                        children: /* @__PURE__ */ jsxRuntime.jsx(
                          designSystem.Typography,
                          {
                            variant: "sigma",
                            textColor: "primary600",
                            fontWeight: "bold",
                            textTransform: "uppercase",
                            children: displayName
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "omega", fontWeight: "semiBold", children: entityLabel })
                  ] }),
                  /* @__PURE__ */ jsxRuntime.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: () => handleRemoveItem(idx),
                      style: {
                        cursor: "pointer",
                        border: "none",
                        background: "transparent",
                        padding: "4px"
                      },
                      "aria-label": "Remove",
                      children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "danger600", fontWeight: "bold", children: "Remove" })
                    }
                  )
                ]
              },
              idx
            );
          })
        ] }),
        !isMany && activeContentType && activeEntityId && /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "neutral600" }),
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Hint, {}),
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Error, {})
      ] }) });
    });
    Input.displayName = "PolymorphicRelationInput";
    exports2.default = Input;
  }
});

// dist/_chunks/index-BxpEVzOm.js
var require_index_BxpEVzOm = __commonJS({
  "dist/_chunks/index-BxpEVzOm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var jsxRuntime = require("react/jsx-runtime");
    var react = require("react");
    var reactIntl = require("react-intl");
    var reactRouterDom = require("react-router-dom");
    var designSystem = require("@strapi/design-system");
    var admin = require("@strapi/strapi/admin");
    var InverseInput = ({ name, attribute }) => {
      const { formatMessage } = reactIntl.useIntl();
      const { get } = admin.useFetchClient();
      const { pathname } = reactRouterDom.useLocation();
      const parts = pathname.split("/");
      const isSingleType = parts.includes("single-types");
      const collectionTypeIndex = parts.indexOf("collection-types");
      const singleTypeIndex = parts.indexOf("single-types");
      const uidIndex = isSingleType ? singleTypeIndex + 1 : collectionTypeIndex + 1;
      const currentUid = parts[uidIndex];
      const currentId = isSingleType ? void 0 : parts[uidIndex + 1];
      const isCreatingEntry = currentId === "create" || !currentId;
      const [relations, setRelations] = react.useState([]);
      const [loading, setLoading] = react.useState(false);
      const [error, setError] = react.useState(null);
      const targetModel = attribute?.options?.targetModel;
      const targetField = attribute?.options?.targetField;
      react.useEffect(() => {
        if (isCreatingEntry)
          return;
        if (!targetModel || !targetField || !currentUid)
          return;
        const fetchRelations = async () => {
          setLoading(true);
          try {
            const { data } = await get("/polymorphic-relation/reverse-relations", {
              params: {
                targetModel,
                targetField,
                displayField: attribute?.options?.targetDisplayField,
                // Pass configured display field
                lookupType: currentUid,
                lookupId: currentId
              }
            });
            setRelations(data.data || []);
          } catch (err) {
            console.error("Failed to fetch reverse relations", err);
            setError(err.message);
          } finally {
            setLoading(false);
          }
        };
        fetchRelations();
      }, [get, targetModel, targetField, currentUid, currentId, isCreatingEntry]);
      if (!targetModel || !targetField) {
        return /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { padding: 4, background: "neutral100", hasRadius: true, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "neutral600", children: "Inverse Polymorphic Relation: Missing configuration (Target Model or Field)." }) });
      }
      return /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Root, { name, children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { direction: "column", alignItems: "stretch", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Field.Label, { children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", fontWeight: "bold", children: attribute?.options?.label || formatMessage({ id: "inverse.label", defaultMessage: "Incoming Relations" }) }) }),
        isCreatingEntry ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "neutral600", children: formatMessage({
          id: "inverse.create",
          defaultMessage: "Save this entry to view related items."
        }) }) : loading ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { justifyContent: "center", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Loader, { small: true, children: "Loading relations..." }) }) : error ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "danger600", children: "Error loading relations." }) : relations.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "neutral600", children: formatMessage({
          id: "inverse.noRelations",
          defaultMessage: "No related items found."
        }) }) : /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { direction: "column", gap: 2, alignItems: "stretch", children: relations.map((item, idx) => {
          const typeName = targetModel ? targetModel.split(".").pop() || targetModel : "Relation";
          const displayName = typeName.charAt(0).toUpperCase() + typeName.slice(1);
          const label = item.title || item.name || item.label || item.subject || item.heading || item.code || item.slug || `ID: ${item.documentId || item.id}`;
          return /* @__PURE__ */ jsxRuntime.jsx(
            designSystem.Flex,
            {
              justifyContent: "space-between",
              alignItems: "center",
              background: "neutral0",
              borderColor: "neutral200",
              borderWidth: "1px",
              borderStyle: "solid",
              hasRadius: true,
              padding: 3,
              shadow: "tableShadow",
              children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 3, alignItems: "center", children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  designSystem.Flex,
                  {
                    background: "primary100",
                    paddingLeft: 2,
                    paddingRight: 2,
                    paddingTop: 1,
                    paddingBottom: 1,
                    hasRadius: true,
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      designSystem.Typography,
                      {
                        variant: "sigma",
                        textColor: "primary600",
                        fontWeight: "bold",
                        textTransform: "uppercase",
                        children: displayName
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "omega", fontWeight: "semiBold", children: label })
              ] })
            },
            idx
          );
        }) })
      ] }) });
    };
    InverseInput.displayName = "PolymorphicRelationInverseInput";
    exports2.default = InverseInput;
  }
});

// dist/_chunks/en-BtwudUdg.js
var require_en_BtwudUdg = __commonJS({
  "dist/_chunks/en-BtwudUdg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var en = {
      "form.label": "Polymorphic Relation",
      "form.description": "Select any content type and entity",
      "form.attribute.item.requiredField": "Required field",
      "form.attribute.item.requiredField.description": "You won't be able to create an entry if this field is empty",
      "field.contentType.placeholder": "Select a content type",
      "field.entity.placeholder": "Select an entity",
      "field.selected": "Selected:",
      "field.type": "Type:",
      "field.id": "ID:",
      "settings.title": "Settings",
      "settings.allowedTypes.label": "Allowed Content Types",
      "settings.allowedTypes.description": "Select which content types can be selected in this field",
      "settings.displayField.label": "Display Field",
      "settings.displayField.description": "Field to display in the selector (default: id)",
      "advanced.title": "Advanced",
      "private.label": "Private field",
      "private.description": "This field will not show up in the API response",
      "settings.relationType.label": "Relation Type",
      "settings.relationType.description": "Choose between single or multiple selection",
      "settings.relationType.one": "Has One (Single)",
      "settings.relationType.many": "Has Many (Multiple)"
    };
    exports2.default = en;
  }
});

// dist/_chunks/uk-TFuM1X69.js
var require_uk_TFuM1X69 = __commonJS({
  "dist/_chunks/uk-TFuM1X69.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
    var uk = {
      "form.label": "\u041F\u043E\u043B\u0456\u043C\u043E\u0440\u0444\u043D\u0435 \u0432\u0456\u0434\u043D\u043E\u0448\u0435\u043D\u043D\u044F",
      "form.description": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u0431\u0443\u0434\u044C-\u044F\u043A\u0438\u0439 \u0442\u0438\u043F \u043A\u043E\u043D\u0442\u0435\u043D\u0442\u0443 \u0442\u0430 \u0441\u0443\u0442\u043D\u0456\u0441\u0442\u044C",
      "form.attribute.item.requiredField": "\u041E\u0431\u043E\u0432'\u044F\u0437\u043A\u043E\u0432\u0435 \u043F\u043E\u043B\u0435",
      "form.attribute.item.requiredField.description": "\u0412\u0438 \u043D\u0435 \u0437\u043C\u043E\u0436\u0435\u0442\u0435 \u0441\u0442\u0432\u043E\u0440\u0438\u0442\u0438 \u0437\u0430\u043F\u0438\u0441, \u044F\u043A\u0449\u043E \u0446\u0435 \u043F\u043E\u043B\u0435 \u043F\u043E\u0440\u043E\u0436\u043D\u0454",
      "field.contentType.placeholder": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u0442\u0438\u043F \u043A\u043E\u043D\u0442\u0435\u043D\u0442\u0443",
      "field.entity.placeholder": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u0441\u0443\u0442\u043D\u0456\u0441\u0442\u044C",
      "field.selected": "\u0412\u0438\u0431\u0440\u0430\u043D\u043E:",
      "field.type": "\u0422\u0438\u043F:",
      "field.id": "ID:",
      "settings.title": "\u041D\u0430\u043B\u0430\u0448\u0442\u0443\u0432\u0430\u043D\u043D\u044F",
      "settings.allowedTypes.label": "\u0414\u043E\u0437\u0432\u043E\u043B\u0435\u043D\u0456 \u0442\u0438\u043F\u0438 \u043A\u043E\u043D\u0442\u0435\u043D\u0442\u0443",
      "settings.allowedTypes.description": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u044F\u043A\u0456 \u0442\u0438\u043F\u0438 \u043A\u043E\u043D\u0442\u0435\u043D\u0442\u0443 \u043C\u043E\u0436\u043D\u0430 \u0432\u0438\u0431\u0438\u0440\u0430\u0442\u0438 \u0432 \u0446\u044C\u043E\u043C\u0443 \u043F\u043E\u043B\u0456",
      "settings.displayField.label": "\u041F\u043E\u043B\u0435 \u0434\u043B\u044F \u0432\u0456\u0434\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043D\u044F",
      "settings.displayField.description": "\u041F\u043E\u043B\u0435 \u0434\u043B\u044F \u0432\u0456\u0434\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043D\u044F \u0432 \u0441\u0435\u043B\u0435\u043A\u0442\u043E\u0440\u0456 (\u0437\u0430 \u0437\u0430\u043C\u043E\u0432\u0447\u0443\u0432\u0430\u043D\u043D\u044F\u043C: id)",
      "advanced.title": "\u0420\u043E\u0437\u0448\u0438\u0440\u0435\u043D\u0456",
      "private.label": "\u041F\u0440\u0438\u0432\u0430\u0442\u043D\u0435 \u043F\u043E\u043B\u0435",
      "private.description": "\u0426\u0435 \u043F\u043E\u043B\u0435 \u043D\u0435 \u0431\u0443\u0434\u0435 \u043F\u043E\u043A\u0430\u0437\u0430\u043D\u043E \u0432 API \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0456",
      "settings.relationType.label": "\u0422\u0438\u043F \u0432\u0456\u0434\u043D\u043E\u0448\u0435\u043D\u043D\u044F",
      "settings.relationType.description": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u043C\u0456\u0436 \u043E\u0434\u0438\u043D\u0438\u0447\u043D\u0438\u043C \u0430\u0431\u043E \u043C\u043D\u043E\u0436\u0438\u043D\u043D\u0438\u043C \u0432\u0438\u0431\u043E\u0440\u043E\u043C",
      "settings.relationType.one": "\u041C\u0430\u0454 \u043E\u0434\u0438\u043D (Single)",
      "settings.relationType.many": "\u041C\u0430\u0454 \u0431\u0430\u0433\u0430\u0442\u043E (Multiple)"
    };
    exports2.default = uk;
  }
});

// dist/_chunks/index-BD8xr598.js
var require_index_BD8xr598 = __commonJS({
  "dist/_chunks/index-BD8xr598.js"(exports2) {
    "use strict";
    var jsxRuntime = require("react/jsx-runtime");
    var icons = require("@strapi/icons");
    var __variableDynamicImportRuntimeHelper = (glob, path, segs) => {
      const v = glob[path];
      if (v) {
        return typeof v === "function" ? v() : Promise.resolve(v);
      }
      return new Promise((_, reject) => {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(
            null,
            new Error(
              "Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
            )
          )
        );
      });
    };
    var PLUGIN_ID = "polymorphic-relation";
    var getTranslation = (id) => `${PLUGIN_ID}.${id}`;
    var PluginIcon = () => {
      return /* @__PURE__ */ jsxRuntime.jsx(icons.Link, {});
    };
    var prefixPluginTranslations = (translations, pluginId) => {
      return Object.keys(translations).reduce(
        (acc, key) => {
          acc[`${pluginId}.${key}`] = translations[key];
          return acc;
        },
        {}
      );
    };
    var index = {
      register(app) {
        app.customFields.register({
          name: "polymorphic-relation",
          pluginId: PLUGIN_ID,
          type: "json",
          intlLabel: {
            id: getTranslation("form.label"),
            defaultMessage: "Polymorphic Relation"
          },
          intlDescription: {
            id: getTranslation("form.description"),
            defaultMessage: "Select any content type and entity"
          },
          icon: PluginIcon,
          components: {
            Input: async () => Promise.resolve().then(() => require_index_C8m5tCNb())
          },
          options: {
            base: [
              {
                name: "options.allowedTypes",
                type: "textarea",
                // Textarea is better for long lists
                intlLabel: {
                  id: getTranslation("settings.allowedTypes.label"),
                  defaultMessage: "Allowed Content Types"
                },
                description: {
                  id: getTranslation("settings.allowedTypes.description"),
                  defaultMessage: "Enter UIDs separated by comma (e.g. api::post.post, api::product.product). Leave empty to allow all (configured in server)."
                }
              },
              {
                name: "options.relationType",
                type: "select",
                intlLabel: {
                  id: getTranslation("settings.relationType.label"),
                  defaultMessage: "Relation Type"
                },
                description: {
                  id: getTranslation("settings.relationType.description"),
                  defaultMessage: "Choose between single or multiple selection"
                },
                options: [
                  {
                    key: "one",
                    value: "one",
                    metadatas: {
                      intlLabel: {
                        id: getTranslation("settings.relationType.one"),
                        defaultMessage: "Has One (Single)"
                      }
                    }
                  },
                  {
                    key: "many",
                    value: "many",
                    metadatas: {
                      intlLabel: {
                        id: getTranslation("settings.relationType.many"),
                        defaultMessage: "Has Many (Multiple)"
                      }
                    }
                  }
                ],
                defaultValue: "one"
              },
              {
                name: "options.displayField",
                type: "text",
                intlLabel: {
                  id: getTranslation("settings.displayField.label"),
                  defaultMessage: "Display Field"
                },
                description: {
                  id: getTranslation("settings.displayField.description"),
                  defaultMessage: "Field to display (default: title)"
                }
              }
            ]
          }
        });
        app.customFields.register({
          name: "inverse-polymorphic-relation",
          pluginId: PLUGIN_ID,
          type: "json",
          intlLabel: {
            id: getTranslation("form.inverse.label"),
            defaultMessage: "Inverse Polymorphic Relation"
          },
          intlDescription: {
            id: getTranslation("form.inverse.description"),
            defaultMessage: "Display entities that reference this entry"
          },
          icon: PluginIcon,
          components: {
            Input: async () => Promise.resolve().then(() => require_index_BxpEVzOm())
          },
          options: {
            base: [
              {
                name: "options.targetModel",
                type: "text",
                intlLabel: {
                  id: getTranslation("settings.targetModel.label"),
                  defaultMessage: "Target Model UID"
                },
                description: {
                  id: getTranslation("settings.targetModel.description"),
                  defaultMessage: "The UID of the model referencing this one (e.g. api::datasheet.datasheet)"
                }
              },
              {
                name: "options.targetField",
                type: "text",
                intlLabel: {
                  id: getTranslation("settings.targetField.label"),
                  defaultMessage: "Target Field Name"
                },
                description: {
                  id: getTranslation("settings.targetField.description"),
                  defaultMessage: "The name of the polymorphic field in the target model"
                }
              },
              {
                name: "options.relationType",
                type: "select",
                intlLabel: {
                  id: getTranslation("settings.inverseRelationType.label"),
                  defaultMessage: "Relation Type"
                },
                description: {
                  id: getTranslation("settings.inverseRelationType.description"),
                  defaultMessage: "Choose between single or multiple results"
                },
                options: [
                  {
                    key: "one",
                    value: "one",
                    metadatas: {
                      intlLabel: {
                        id: getTranslation("settings.relationType.one"),
                        defaultMessage: "Has One (Single)"
                      }
                    }
                  },
                  {
                    key: "many",
                    value: "many",
                    metadatas: {
                      intlLabel: {
                        id: getTranslation("settings.relationType.many"),
                        defaultMessage: "Has Many (Multiple)"
                      }
                    }
                  }
                ],
                defaultValue: "many"
              },
              {
                name: "options.targetDisplayField",
                type: "text",
                intlLabel: {
                  id: getTranslation("settings.targetDisplayField.label"),
                  defaultMessage: "Target Display Field"
                },
                description: {
                  id: getTranslation("settings.targetDisplayField.description"),
                  defaultMessage: "Field to display independently (e.g. title, name). Leave empty for ID"
                }
              },
              {
                name: "options.label",
                type: "text",
                intlLabel: {
                  id: getTranslation("settings.label.label"),
                  defaultMessage: "Label"
                },
                description: {
                  id: getTranslation("settings.label.description"),
                  defaultMessage: "Custom label to specificy the relation title (default: Incoming Relations)"
                }
              }
            ]
          }
        });
        const plugin = {
          id: PLUGIN_ID,
          initializer: () => null,
          isReady: true,
          name: PLUGIN_ID
        };
        app.registerPlugin(plugin);
      },
      async registerTrads({ locales }) {
        const importedTranslations = await Promise.all(
          locales.map((locale) => {
            return __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "./translations/en.json": () => Promise.resolve().then(() => require_en_BtwudUdg()), "./translations/uk.json": () => Promise.resolve().then(() => require_uk_TFuM1X69()) }), `./translations/${locale}.json`, 3).then(({ default: data }) => {
              return {
                data: prefixPluginTranslations(data, PLUGIN_ID),
                locale
              };
            }).catch(() => {
              return {
                data: {},
                locale
              };
            });
          })
        );
        return importedTranslations;
      }
    };
    exports2.getTranslation = getTranslation;
    exports2.index = index;
  }
});

// dist/admin/index.js
var require_admin = __commonJS({
  "dist/admin/index.js"(exports2, module2) {
    "use strict";
    var index = require_index_BD8xr598();
    module2.exports = index.index;
  }
});

// dist/server/index.js
var require_server = __commonJS({
  "dist/server/index.js"(exports2, module2) {
    "use strict";
    var register = ({ strapi }) => {
      strapi.customFields.register({
        name: "polymorphic-relation",
        plugin: "polymorphic-relation",
        type: "json"
      });
      strapi.customFields.register({
        name: "content-type-select",
        plugin: "polymorphic-relation",
        type: "json"
      });
      strapi.customFields.register({
        name: "inverse-polymorphic-relation",
        plugin: "polymorphic-relation",
        type: "json"
      });
      strapi.log.info("\u2705 Polymorphic Relations custom field registered on server");
    };
    var bootstrap = ({ strapi }) => {
      strapi.server.use(async (ctx, next) => {
        await next();
        if (ctx.url.startsWith("/api/") && ctx.body && ctx.body.data && ctx.response.status >= 200 && ctx.response.status < 300) {
          try {
            const polymorphicService2 = strapi.plugin("polymorphic-relation").service("polymorphic");
            let modelUID;
            try {
              const pathParts = ctx.url.split("?")[0].split("/");
              if (pathParts.length >= 3 && pathParts[1] === "api") {
                const pluralName = pathParts[2];
                for (const [uid, type] of Object.entries(strapi.contentTypes)) {
                  if (type.info?.pluralName === pluralName) {
                    modelUID = uid;
                    break;
                  }
                }
              }
            } catch (e) {
            }
            if (modelUID) {
              strapi.log.debug(`[Polymorphic] Detected model ${modelUID} for auto-populate.`);
            } else {
              strapi.log.warn(`[Polymorphic] Could not resolve model UID from URL: ${ctx.url}`);
            }
            const populateParams = ctx.query.populate;
            await polymorphicService2.populatePolymorphicFields(ctx.body.data, modelUID, populateParams);
          } catch (error) {
            strapi.log.error("\u274C Error auto-populating polymorphic fields:", error.message);
          }
        }
      });
      strapi.log.info("\u2705 Polymorphic Relations plugin bootstrapped");
    };
    var polymorphicService = ({ strapi }) => ({
      /**
       * Resolve polymorphic relation and return full entity data
       */
      async resolvePolymorphicRelation(fieldValue, options = {}) {
        if (!fieldValue || !fieldValue.contentType || !fieldValue.id) {
          return null;
        }
        const { contentType, id } = fieldValue;
        try {
          const entity = await strapi.documents(contentType).findOne({
            documentId: id,
            ...options
          });
          if (!entity) {
            strapi.log.debug(`\u26A0\uFE0F Entity not found: ${contentType} with id ${id}`);
            return null;
          }
          return {
            __contentType: contentType,
            ...entity
          };
        } catch (error) {
          strapi.log.error(`\u274C Error resolving polymorphic relation: ${error.message}`);
          return null;
        }
      },
      /**
       * Recursively populate all polymorphic fields in data
       */
      /**
       * Recursively populate all polymorphic fields in data
       */
      async populatePolymorphicFields(data, modelUID, populateParams) {
        if (!data)
          return;
        const shouldPopulate = (field) => {
          if (!populateParams)
            return false;
          if (populateParams === "*" || populateParams === true)
            return true;
          if (typeof populateParams === "string") {
            return populateParams.split(",").map((s) => s.trim()).includes(field);
          }
          if (Array.isArray(populateParams))
            return populateParams.includes(field);
          if (typeof populateParams === "object") {
            return field in populateParams || populateParams["*"];
          }
          return false;
        };
        const getNestedPopulate = (field) => {
          if (typeof populateParams === "object" && populateParams !== null && populateParams[field]) {
            return populateParams[field];
          }
          return void 0;
        };
        if (modelUID) {
          const model = strapi.contentTypes[modelUID];
          if (model) {
            const attributes = model.attributes || {};
            const inverseFields = Object.entries(attributes).filter(
              ([_, attr]) => attr.customField === "plugin::polymorphic-relation.inverse-polymorphic-relation"
            );
            for (const [fieldName, attr] of inverseFields) {
              const shouldExpand = shouldPopulate(fieldName);
              const options = attr.options || {};
              const { targetModel, targetField, targetDisplayField, relationType } = options;
              const processSingle = async (item) => {
                if (item && typeof item === "object") {
                  if (targetModel && targetField) {
                    try {
                      const relations = await this.findReverseRelations(
                        targetModel,
                        targetField,
                        modelUID,
                        item.documentId || item.id,
                        targetDisplayField
                      );
                      const isSingle = relationType === "one";
                      if (shouldExpand) {
                        const nestedPopulate = getNestedPopulate(fieldName);
                        await this.populatePolymorphicFields(
                          relations,
                          targetModel,
                          nestedPopulate || populateParams
                        );
                        item[fieldName] = isSingle ? relations[0] || null : relations;
                      } else {
                        const ids = relations.map((rel) => ({
                          id: rel.documentId || rel.id
                        }));
                        item[fieldName] = isSingle ? ids[0] || null : ids;
                      }
                      strapi.log.debug(
                        `[Polymorphic] Populated ${fieldName} with ${relations.length} items (expanded: ${shouldExpand}, type: ${relationType || "many"})`
                      );
                    } catch (e) {
                      strapi.log.warn(`Failed to populate inverse relation ${fieldName}: ${e}`);
                    }
                  }
                }
              };
              if (Array.isArray(data)) {
                await Promise.all(data.map((item) => processSingle(item)));
              } else {
                await processSingle(data);
              }
            }
          } else {
            strapi.log.debug(`[Polymorphic] Model ${modelUID} not found in contentTypes`);
          }
        }
        const isPolymorphic = (value) => {
          return value && typeof value === "object" && "contentType" in value && "id" in value;
        };
        const processItem = async (item) => {
          if (!item || typeof item !== "object")
            return;
          for (const [key, value] of Object.entries(item)) {
            if (isPolymorphic(value) && !Array.isArray(value) && !value.__contentType) {
              if (shouldPopulate(key)) {
                const nestedPopulate = getNestedPopulate(key);
                const resolved = await this.resolvePolymorphicRelation(value, {
                  populate: nestedPopulate
                });
                if (resolved) {
                  item[key] = resolved;
                }
              }
            } else if (Array.isArray(value)) {
              if (value.length > 0 && isPolymorphic(value[0]) && !value[0].__contentType) {
                if (shouldPopulate(key)) {
                  const nestedPopulate = getNestedPopulate(key);
                  const resolvedItems = await Promise.all(
                    value.map(
                      (v) => this.resolvePolymorphicRelation(v, {
                        populate: nestedPopulate
                      })
                    )
                  );
                  item[key] = resolvedItems.filter((r) => r !== null);
                }
              } else {
                const nestedPopulate = getNestedPopulate(key);
                if (nestedPopulate || populateParams === "*" || populateParams === true) {
                  await Promise.all(
                    value.map((v) => this.populatePolymorphicFields(v, void 0, nestedPopulate))
                  );
                }
              }
            } else if (value && typeof value === "object") {
              const nestedPopulate = getNestedPopulate(key);
              if (nestedPopulate || populateParams === "*" || populateParams === true) {
                await this.populatePolymorphicFields(value, void 0, nestedPopulate);
              }
            }
          }
        };
        if (Array.isArray(data)) {
          await Promise.all(data.map((item) => processItem(item)));
        } else {
          await processItem(data);
        }
      },
      /**
       * Get list of available content types for selector
       */
      getAvailableContentTypes() {
        const contentTypes = strapi.contentTypes;
        const availableTypes = [];
        const config2 = strapi.plugin("polymorphic-relation").config;
        const allowedTypes = config2("allowedTypes") || [];
        const ignoredTypes = config2("ignoredTypes") || [];
        for (const [uid, contentType] of Object.entries(contentTypes)) {
          const ct = contentType;
          if (allowedTypes.length > 0 && !allowedTypes.includes(uid)) {
            continue;
          }
          if (ignoredTypes.includes(uid)) {
            continue;
          }
          availableTypes.push({
            uid,
            apiID: ct.apiID || uid.split(".").pop() || uid,
            displayName: ct.info?.displayName || ct.globalId,
            kind: ct.kind,
            visible: ct.visible !== false
          });
        }
        return availableTypes.sort((a, b) => a.displayName.localeCompare(b.displayName));
      },
      /**
       * Validate polymorphic field value
       */
      async validatePolymorphicValue(value, allowedTypes = []) {
        if (!value)
          return true;
        if (!value.contentType || !value.id) {
          throw new Error("Polymorphic relation must have contentType and id properties");
        }
        if (allowedTypes.length > 0 && !allowedTypes.includes(value.contentType)) {
          throw new Error(
            `Content type "${value.contentType}" is not in allowed types: ${allowedTypes.join(", ")}`
          );
        }
        if (!strapi.contentTypes[value.contentType]) {
          throw new Error(`Content type "${value.contentType}" does not exist`);
        }
        try {
          const exists = await strapi.documents(value.contentType).findOne({
            documentId: value.id
          });
          if (!exists) {
            throw new Error(
              `Entity with id "${value.id}" not found in content type "${value.contentType}"`
            );
          }
        } catch (error) {
          throw new Error(`Invalid content type or entity: ${error.message}`);
        }
        return true;
      },
      /**
       * Find identifying reverse relations
       * Finds entities of 'targetModel' where 'targetField' points to { lookupType, lookupId }
       */
      async findReverseRelations(targetModel, targetField, lookupType, lookupId, displayField) {
        try {
          const model = strapi.contentTypes[targetModel];
          const attributes = model?.attributes || {};
          const fieldsToSelect = ["id", "documentId", targetField];
          if (displayField && attributes[displayField]) {
            fieldsToSelect.push(displayField);
          }
          const entries = await strapi.db.query(targetModel).findMany({
            select: fieldsToSelect,
            limit: 1e3
          });
          if (!entries) {
            return [];
          }
          const results = entries.filter((entry) => {
            const val = entry[targetField];
            if (!val)
              return false;
            let isMatch = false;
            const checkItem = (item) => {
              return item?.contentType === lookupType && String(item?.id) === String(lookupId);
            };
            if (Array.isArray(val)) {
              isMatch = val.some((item) => checkItem(item));
            } else if (typeof val === "object") {
              isMatch = checkItem(val);
            } else if (typeof val === "string") {
              try {
                const parsed = JSON.parse(val);
                if (Array.isArray(parsed)) {
                  isMatch = parsed.some((item) => checkItem(item));
                } else {
                  isMatch = checkItem(parsed);
                }
              } catch (e) {
              }
            }
            if (isMatch) {
            }
            return isMatch;
          });
          const uniqueResults = filterByDocumentId(results);
          return uniqueResults;
        } catch (error) {
          strapi.log.error(`Error finding reverse relations: ${error}`);
          return [];
        }
      }
    });
    function filterByDocumentId(entities) {
      const seen = /* @__PURE__ */ new Set();
      return entities.filter((entity) => {
        if (!entity.documentId)
          return true;
        if (seen.has(entity.documentId))
          return false;
        seen.add(entity.documentId);
        return true;
      });
    }
    var services = {
      polymorphic: polymorphicService
    };
    var polymorphicController = ({ strapi }) => ({
      /**
       * GET /api/polymorphic-relation/content-types
       * Get list of available content types
       */
      async getContentTypes(ctx) {
        try {
          const polymorphicService2 = strapi.plugin("polymorphic-relation").service("polymorphic");
          const contentTypes = polymorphicService2.getAvailableContentTypes();
          ctx.body = {
            data: contentTypes
          };
        } catch (error) {
          ctx.throw(500, `Failed to fetch content types: ${error.message}`);
        }
      },
      /**
       * GET /api/polymorphic-relation/content-types/:contentType/entities
       * Get entities for a specific content type
       */
      async getEntities(ctx) {
        try {
          const { contentType } = ctx.params;
          const { search, page = 1, pageSize = 10 } = ctx.query;
          if (!strapi.contentTypes[contentType]) {
            return ctx.throw(404, `Content type "${contentType}" not found`);
          }
          const queryOptions = {
            pagination: {
              page: parseInt(page, 10),
              pageSize: parseInt(pageSize, 10)
            }
          };
          if (search) {
            queryOptions.filters = {
              $or: [
                { title: { $containsi: search } },
                { name: { $containsi: search } },
                { displayName: { $containsi: search } }
              ]
            };
          }
          const result = await strapi.documents(contentType).findMany(queryOptions);
          ctx.body = {
            data: result,
            meta: {
              pagination: queryOptions.pagination
            }
          };
        } catch (error) {
          ctx.throw(500, `Failed to fetch entities: ${error.message}`);
        }
      },
      /**
       * GET /api/polymorphic-relation/content-types/:contentType/entities/:id
       * Get a specific entity
       */
      async getEntity(ctx) {
        try {
          const { contentType, id } = ctx.params;
          if (!strapi.contentTypes[contentType]) {
            return ctx.throw(404, `Content type "${contentType}" not found`);
          }
          const entity = await strapi.documents(contentType).findOne({
            documentId: id
          });
          if (!entity) {
            return ctx.throw(404, `Entity with id "${id}" not found`);
          }
          ctx.body = {
            data: entity
          };
        } catch (error) {
          ctx.throw(500, `Failed to fetch entity: ${error.message}`);
        }
      },
      /**
       * GET /api/polymorphic-relation/reverse-relations
       * Find identifying reverse relations
       */
      async findReverseRelations(ctx) {
        try {
          const { targetModel, targetField, lookupType, lookupId } = ctx.query;
          if (!targetModel || !targetField || !lookupType || !lookupId) {
            return ctx.throw(
              400,
              "Missing required query parameters: targetModel, targetField, lookupType, lookupId"
            );
          }
          const polymorphicService2 = strapi.plugin("polymorphic-relation").service("polymorphic");
          const results = await polymorphicService2.findReverseRelations(
            targetModel,
            targetField,
            lookupType,
            lookupId
          );
          ctx.body = {
            data: results
          };
        } catch (error) {
          ctx.throw(500, `Failed to find reverse relations: ${error.message}`);
        }
      }
    });
    var controllers = {
      polymorphic: polymorphicController
    };
    var routes = [
      {
        method: "GET",
        path: "/content-types",
        handler: "polymorphic.getContentTypes",
        config: {
          policies: []
        }
      },
      {
        method: "GET",
        path: "/content-types/:contentType/entities",
        handler: "polymorphic.getEntities",
        config: {
          policies: []
        }
      },
      {
        method: "GET",
        path: "/content-types/:contentType/entities/:id",
        handler: "polymorphic.getEntity",
        config: {
          policies: []
        }
      },
      {
        method: "GET",
        path: "/reverse-relations",
        handler: "polymorphic.findReverseRelations",
        config: {
          policies: []
        }
      }
    ];
    var config = {
      default: {
        allowedTypes: [],
        // Empty means all types are allowed (unless ignored)
        ignoredTypes: [
          "admin::permission",
          "admin::user",
          "admin::role",
          "admin::api-token",
          "admin::api-token-permission",
          "admin::transfer-token",
          "admin::transfer-token-permission",
          "plugin::upload.file",
          "plugin::upload.folder",
          "plugin::i18n.locale",
          "plugin::users-permissions.permission",
          "plugin::users-permissions.role",
          "plugin::content-releases.release",
          "plugin::content-releases.release-action"
        ]
      },
      validator() {
      }
    };
    var serverExport = {
      register,
      bootstrap,
      services,
      controllers,
      routes,
      config
    };
    module2.exports = serverExport;
  }
});

// <stdin>
require_admin();
require_server();
